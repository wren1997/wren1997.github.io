---
layout:     post
title:      编译原理实验二：预测分析算法的设计与实现
subtitle:   编译原理
date:       2018-11-15
author:     王政乔
catalog: true
tags:
    - 编译原理
    - 实验
    - 词法分析
    - 代码存档
    - python
---

## 编译原理实验二：预测分析算法的设计与实现

人生苦短，我用python。虽然代码量比起那些大佬们的c语言还是多了些，但起码....意料之外的bug就少了很多。

我把功能封装到类中，这次代码是我注释最多的一次，要不根本没办法修改，毕竟python的可维护性之差是有目共睹的。

代码还没有完成，最后一步也就是根据输入串，输出预测分析过程这块，现在刚学到，课本上内容还没有看明白，等弄懂了再说。



直接放源码～

tc2.py

```python
import prettytable as pt
import sys

sys.setrecursionlimit(1000000)

class tc2(object):

    __dic_formula={} #产生式的字典
    __terSymbol=['#'] #终结符号
    __non_ter=[] #非终结符号
    __firstSET={} #各产生式的first集合
    __followSET={} #各产生式的follow集合
    __startsign=''
    __emptysign='$' #设置空的标识符
    __anatable=[]
    tb=pt.PrettyTable()
    __tablem={} #用于存放预测分析数据的字典，其结构是
    # __tablem={终结符:[[上级非终结符,产生式],[]]}
    incount=0


    def __init__(self):
        print("-------实验二-预测分析算法的设计与实现---------")
        print("作者：王政乔 20160520126")
        pass
    
    def insert_wf(self,filepath):
        #输入文法
        fileread=open(filepath,mode='r')
        filereadtxt=fileread.readlines()
        for i in range(0,len(filereadtxt)-1):
            filereadtxt[i]=filereadtxt[i].rstrip('\n') #去掉右侧的\n符号
        print("----文本内容----")
        print(filereadtxt)
        self.__startsign=filereadtxt[0][0]
        for i in range(0,len(filereadtxt)):
            flagindex=filereadtxt[i].find("->") #从左到右找到第一个->符号
            if flagindex>3:
                #->符号太靠右了，说明一定有问题
                print("格式错误")
            #开始进行分割操作
            #print(filereadtxt[i][flagindex+2:]) #这个是把左侧内容清除掉后的内容
            strright=filereadtxt[i][flagindex+2:]
            tdf=[]
            tdf=strright.split('|')
            #print(tdf)
            if filereadtxt[i][flagindex-1] in self.__dic_formula:
                #如果产生式的字典里已经存在这个非终结符
                self.__dic_formula[filereadtxt[i][flagindex-1]]+=tdf
            else:
                #这是一个全新的非终结符
                self.__dic_formula[filereadtxt[i][flagindex-1]]=tdf
                self.__non_ter.append(filereadtxt[i][flagindex-1])
        self.__non_ter.sort()
        
        pass
    
    def getfirst(self,instring="nostring"): #获得first集合
        if instring!="nostring":
            #说明有字符串传入
            print("---字符串的first集合")

        else:
            #说明直接操作类中集合
            print("---类中产生式的first集合")
            for key in self.__dic_formula:
                #遍历字典的索引
                firstlist=[]
                for i in range(0,len(self.__dic_formula[key])):
                    #遍历字典存储的产生式
                    j=0
                    temps=self.__dic_formula[key][i]
                    while(temps[j] in self.__non_ter):
                        #如果该字符是非终结符
                        temps=self.__dic_formula[temps[j]][i]
                    else:
                        #如果该字符是终结符
                        if(temps[j] not in self.__terSymbol):
                            #如果这个终结符未被记录
                            self.__terSymbol.append(temps[j])
                        firstlist.append(temps[j])
                self.__firstSET[key]=firstlist
        print(self.__firstSET)
        pass


    def getsfirst_t(self,func="1"):
        #print("----first集合------")
        if func=="1": #默认的是直接求first集合
            for key in self.__dic_formula:
                self.getsfirst_d(key,key)
            print(self.__firstSET)
        
        else:
            #求字符串的集合
            #print("-----求字符串" + func + "的first集合")
            if func[0] in self.__non_ter:
                #第一位是非终结符
                return self.__firstSET[func[0]]
            else:
                tl=[]
                tl.append(func[0])
                return tl
        pass

    firstl=[]
    def getsfirst_d(self,valuekey,inkey):
        #自我递归
        firstlist=[]
        for i in range(0,len(self.__dic_formula[inkey])): #依次寻找first集合
            #print("digui " + str(self.incount))
            self.incount+=1

            temps=self.__dic_formula[inkey][i]
            #print(temps)
            if(temps[0] in self.__non_ter) and self.incount<9000 : #首字母为非终结符
                self.getsfirst_d(valuekey,temps[0])
            else: #首字母为终结符
                #self.firstl.append(temps[0])
                if valuekey in self.__firstSET:
                    firstlist=self.__firstSET[valuekey]
                    #print(firstlist)
                if temps[0] not in firstlist:
                    firstlist.append(temps[0])
                firstlist.sort()
                self.__firstSET[valuekey]=firstlist
        pass
    
    def getsfollow_d(self):
        #求follow
        follows=[]
        follows.append('#')
        self.__followSET[self.__startsign]=follows
        #第一步
        #思路是第一次无所谓终结符非终结符，只要非空，那么就把它放到follow集合中。
        #然后对follow集合进行反复更改，清除集合里面的非终结符
        for key in self.__dic_formula:
            #对产生式进行遍历
            for i in range(0,len(self.__dic_formula[key])):
                #遍历产生式里面的元素
                for j in range(0,len(self.__dic_formula[key][i])):
                    #遍历产生式里的元素的字符
                    if self.__dic_formula[key][i][j] in self.__non_ter:
                        #如果发现字母是非终结符
                        if j!=len(self.__dic_formula[key][i])-1:
                            #如果字母不是最后一位的
                            follows=[] #清空一下
                            if self.__dic_formula[key][i][j] in self.__followSET:
                                #如果follow集合里存在这个非终结符
                                follows=self.__followSET[self.__dic_formula[key][i][j]]
                            if self.__dic_formula[key][i][j+1] in self.__non_ter:
                                #如果这个非终结符的下一位还是非终结符（要求下一位的first集合了)
                                follows+=self.__firstSET[self.__dic_formula[key][i][j+1]]
                                follows.remove(self.__emptysign)#清空follow集合里面的空集
                                if self.__emptysign in self.__dic_formula[self.__dic_formula[key][i][j+1]]:
                                    #如果这个非终结符的产生式能产生空值
                                    if self.__dic_formula[key][i][j+1] in self.__followSET:
                                        follows+=self.__followSET[self.__dic_formula[key][i][j+1]]
                                    else:
                                        follows+=[self.__dic_formula[key][i][j+1]]
                            else:
                                follows.append(self.__dic_formula[key][i][j+1]) 
                                #把非终结符后一位的放到follow集合里
                            follows=list(set(follows)) #follow集合去重
                            self.__followSET[self.__dic_formula[key][i][j]]=follows
                        else:
                            #如果字母是最后一位的
                            follows=[] #清空一下
                            if self.__dic_formula[key][i][j] in self.__followSET:
                                #如果follow集合里存在这个非终结符
                                follows=self.__followSET[self.__dic_formula[key][i][j]]
                            follows.append(key) 
                            #把索引key放到follow集合里
                            follows.sort()
                            self.__followSET[self.__dic_formula[key][i][j]]=follows
        #第二步 将follow集合里面的非终结符，再取其follow
        for counts in range(0,len(self.__non_ter)):
            #为了保证深度，预计重叠的深度不会大于非终结符的数量
            for key in self.__followSET:
                #重复遍历follow集合
                for i in range(0,len(self.__followSET[key])):
                    #遍历每一个follow集里的每一个元素
                    if self.__followSET[key][i] in self.__non_ter:
                        #如果这个元素是非终结符
                        follows=[] #清空初始化
                        if self.__followSET[key][i] in self.__followSET:
                            #就怕这个是个全新的未出现的follow集合，那就尴尬了
                            follows=self.__followSET[key]
                            follows+=self.__followSET[self.__followSET[key][i]]
                        follows=list(set(follows)) #follow集合去重
                        follows.sort()
                        self.__followSET[key]=follows

        #第三步 收尾，清除follow集合里面的所有非终结符
        for key in self.__followSET:
            i=0
            while i<len(self.__followSET[key]):
                if self.__followSET[key][i] in self.__non_ter:
                    self.__followSET[key].remove(self.__followSET[key][i])
                else:
                    i=i+1
            self.__followSET[key].sort()
        pass
    
    def setterSymbol(self):
        #添加非终结符
        for key in self.__dic_formula:
            for i in range(0,len(self.__dic_formula[key])):
                for j in range(0,len(self.__dic_formula[key][i])):
                    if self.__dic_formula[key][i][j] not in self.__non_ter:
                        self.__terSymbol.append(self.__dic_formula[key][i][j])
        self.__terSymbol=list(set(self.__terSymbol))
        self.__terSymbol.sort()
        pass

    def makeanalysetable(self):
        #构建分析表
        for formlula in self.__dic_formula:
            for i in range(0,len(self.__dic_formula[formlula])):
                firstlist=self.getsfirst_t(self.__dic_formula[formlula][i])
                for flitem in firstlist:
                    if flitem!=self.__emptysign:
                        #如果非空
                        tempinlist=[]
                        if flitem in self.__tablem:
                            tempinlist=self.__tablem[flitem]
                        tempinlist.append([formlula,self.__dic_formula[formlula][i]])
                        self.__tablem[flitem]=tempinlist
                        #print("M[" + formlula + "," + flitem + "]::" + formlula + "->" + self.__dic_formula[formlula][i])
                    else:
                        #如果是空
                        for itemfollow in self.__terSymbol + ['#']:
                            if itemfollow in self.__followSET[formlula]:
                                tempinlist=[]
                                if itemfollow in self.__tablem:
                                    tempinlist=self.__tablem[itemfollow]
                                tempinlist.append([formlula,self.__emptysign])
                                self.__tablem[itemfollow]=tempinlist
                                #print("M[" + formlula + "," + itemfollow + "]::" + formlula + "->" + self.__emptysign)
        pass
    
    def showanalytable(self):
        
        self.tb.field_names=['word']+self.__terSymbol 
        for nonitem in self.__non_ter:
            self.__anatable.append([nonitem]+['error']*(len(self.tb.field_names)-1))
        #显示分析表
        #print(self.__tablem)
        for items in self.__tablem:
            for i in range(0,len(self.__tablem[items])):
                pos_non=self.__non_ter.index(self.__tablem[items][i][0])
                pos_ter=self.__terSymbol.index(items)
                #print("non,"+ self.__non_ter[pos_non] +":" + str(pos_non) + " ter," + self.__terSymbol[pos_ter] + ":" + str(pos_ter) + " value:"+self.__tablem[items][i][1])
                #print(pos),
                #print("-" + self.__non_ter[pos])
                self.__anatable[pos_non][pos_ter+1]=self.__non_ter[pos_non]+"->"+self.__tablem[items][i][1]
        
        for lines in self.__anatable:
            self.tb.add_row(lines)
        
        #print(self.__anatable)
        print(self.tb)
        pass

    def printall(self):
        print("-------结果--------")
        print("--产生式：")
        print(self.__dic_formula)
        print("--终结符：")
        print(self.__terSymbol)
        print("--非终结符：")
        print(self.__non_ter)
        print("--first集：")
        print(self.__firstSET)
        print("--follow集：")
        print(self.__followSET)
        
        
    

```

之后可以在另一个文件里引用，就非常的简单

test2.py

```python
import tc2
import os

print("\033c") #清屏
x=tc2.tc2()
x.insert_wf("h1.txt")
x.getsfirst_t()
x.getsfollow_d()
x.setterSymbol()
x.printall()
x.makeanalysetable()
x.showanalytable()



```

在使用时，只需要

```bash
python test2.py
```

即可运行～，文法存放在h1.txt中，于同一目录下，格式如下：

> E->TR
> R->+E|$
> T->FY
> Y->T|$
> F->PG
> G->*G|$
> P->(E)|a|b|^

最后输出的结果如下：

```
-------实验二-预测分析算法的设计与实现---------
作者：王政乔 20160520126
----文本内容----
['E->TR', 'R->+E|$', 'T->FY', 'Y->T|$', 'F->PG', 'G->*G|$', 'P->(E)|a|b|^']
{'E': ['(', '^', 'a', 'b'], 'R': ['$', '+'], 'T': ['(', '^', 'a', 'b'], 'Y': ['$', '(', '^', 'a', 'b'], 'F': ['(', '^', 'a', 'b'], 'G': ['$', '*'], 'P': ['(', '^', 'a', 'b']}
-------结果--------
--产生式：
{'E': ['TR'], 'R': ['+E', '$'], 'T': ['FY'], 'Y': ['T', '$'], 'F': ['PG'], 'G': ['*G', '$'], 'P': ['(E)', 'a', 'b', '^']}
--终结符：
['#', '$', '(', ')', '*', '+', '^', 'a', 'b']
--非终结符：
['E', 'F', 'G', 'P', 'R', 'T', 'Y']
--first集：
{'E': ['(', '^', 'a', 'b'], 'R': ['$', '+'], 'T': ['(', '^', 'a', 'b'], 'Y': ['$', '(', '^', 'a', 'b'], 'F': ['(', '^', 'a', 'b'], 'G': ['$', '*'], 'P': ['(', '^', 'a', 'b']}
--follow集：
{'E': ['#', ')'], 'T': ['#', ')', '+'], 'R': ['#', ')'], 'F': ['#', '(', ')', '+', '^', 'a', 'b'], 'Y': ['#', ')', '+'], 'P': ['#', '(', ')', '*', '+', '^', 'a', 'b'], 'G': ['#', '(', ')', '+', '^', 'a', 'b']}
+------+-------+-------+--------+-------+-------+-------+-------+-------+-------+
| word |   #   |   $   |   (    |   )   |   *   |   +   |   ^   |   a   |   b   |
+------+-------+-------+--------+-------+-------+-------+-------+-------+-------+
|  E   | error | error | E->TR  | error | error | error | E->TR | E->TR | E->TR |
|  F   | error | error | F->PG  | error | error | error | F->PG | F->PG | F->PG |
|  G   |  G->$ | error |  G->$  |  G->$ | G->*G |  G->$ |  G->$ |  G->$ |  G->$ |
|  P   | error | error | P->(E) | error | error | error |  P->^ |  P->a |  P->b |
|  R   |  R->$ | error | error  |  R->$ | error | R->+E | error | error | error |
|  T   | error | error | T->FY  | error | error | error | T->FY | T->FY | T->FY |
|  Y   |  Y->$ | error |  Y->T  |  Y->$ | error |  Y->$ |  Y->T |  Y->T |  Y->T |
+------+-------+-------+--------+-------+-------+-------+-------+-------+-------+
joger@joger-PC:~/Documents/编译原理$ 

```

